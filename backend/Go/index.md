# 基础知识

## 1. 变量

变量是相当于是对一块数据存储空间的命名，程序可以通过定义一个变量来申请一块数据空间，之后可以通过过引用变量名来
使用这块存储空间。

Go 语言中，对于纯粹的变量声明使用关键字 `var`

``` go
var v1 int
var v2 string
var v3 [10]int          // 数组
var v4 []int            // 数组切片
var v5 struct { 
 f int
} 
var v6 *int             // 指针
var v7 map[string]int   // map，key 为 string 类型，value 为 int 类型
var v8 func(a int) int
```

`var` 关键字的另一种用法是可以将若干个需要声明的变量放置在一起，一次性声明

```go
var (
    v1 int
    v2 string
)
```

### 1.1 变量初始化

对于声明变量时需要进行初始化的场景，`var` 关键字可以保留，但不再是必要的元素，例如：

```go
var v1 int = 100
var v2 = 10
v3: 10
```

以上三种用法的效果是完全一样的，并且 Go 语言也引入了个 C 和 C++ 中没有的符号组合 `:=`，用于明确表达同时进行变量声明和初始化的工作。

>[!info] 补充：
>
> 指定类型已不再是必须的，Go 编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型，因此这让 Go 语言看起来有点像动态类型语言，尽管 Go 语言实际上是不折不扣的强类型语言（静态类型语言）。

>[!important] 注意：
>
>出现在 `:=` 左侧的变量不应该是已被声明过的，否则将会导致 `no new variables on left side of :=`  的编译错误
>
>```go
>var i int
>i := 2
>```
>
>但是存在例外情况：
>
>只要左边的变量列表中至少有一个是新声明的变量，编译器就不会报错，即使他已是被声明过的
>
>```go
>package main
>
>import "fmt"
>
> func main() {
>   a, b := 1, 2
>   fmt.Println(a, b)   // 1 2
>   a, c := 3, 4    
>   fmt.Println(a, c)   // 3 4
> }
>```

### 1.2 变量赋值

在 Go 语法中，变量初始化和变量赋值是两个不同的概念。如下声明一个变量之后的赋值过程：

```go
var v10 int
v10 = 100
```

除了上述最基本的赋值形式， Go 语言中还提供了 C/C++ 程序员期盼多年的`多重赋值功能`，比如下面这个交换 i 和 j 变量的语句：

```go
i := 100
j := 200

i,j = j,i
```

### 1.3 匿名变量

在使用传统的强类型语言编程时，经常会出现：在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没用的变量。在 Go 中可以通过结合使用`多重返回`和`匿名变量`来避免这种丑陋的写法，让代码看起来更加优雅。

```go
func getName() (firstName, lastName, nickname string) {
 return  "May", "Chan", "Chibi Maruko"
}
```

若只想获得 nickName，则函数调用语句可以用如下方式编写：

```go
_, _, nickName := GetName()
```

:::import 注意：

1. 匿名变量以“_”下划线表示
2. 匿名变量不占用命名空间，也不会分配内存。匿名变量可以重复声明使用
3. “_”本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。

:::

## 2. 常量

在Go语言中，常量是指编译期间就已知且不可改变的值。常量可以是数值类型（包括整型、浮点型和复数类型）、布尔类型、字符串类型等。

### 2.1 常量定义

通过关键字 `const` 就可以给指定的字面量指定名称

```go
const Pi float64 = 3.14159265358979323846
const zero = 0.0            // 无类型浮点常量
const (
 size int64 = 1024 
 eof = -1                   // 无类型整型常量
) 
const u, v float32 = 0, 3   // u = 0.0, v = 3.0，常量的多重赋值
const a, b, c = 3, 4, "foo" // a = 3, b = 4, c = "foo",无类型整型和字符串常量
```

Go 的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么它与字面常量一样，是无类型常量。

>[!important]注意：
>
>常量的赋值是一个编译期行为，所以右值不能出现任何需要在运行期才能得出结果的表达式，例如：
>
>```go
>const Home = os.getEnv("HOME")
>```
>
>这种方式定义常量将会导致编译错误 `os.GetEnv()`只有在运行期才能知道返回结果，在编译期并不能确定，所以无法作为常量定义的右值。

### 2.2 预定义常量

Go 语言预定义了这些常量：true、false 和 iota。其中 `iota` 比较特殊，可以被认为是一个可被编译器修改的常量，在每一个 const 关键字出现时被
重置为 0，然后在下一个 const 出现之前，每出现一次 iota，其所代表的数字会自动增 1

```go
const (             // iota 被重置为 0
    c0 = iota       // 0
    c1 = iota       // 1
    c2 = iota       // 2
)

const (
    u         = iota * 42   // u == 0
    v float64 = iota * 42   // v == 42.0
    w         = iota * 42   // 84
)

const x = iota      // 0
const y = iota      // 0
```

如果两个 const 的赋值语句的表达式是一样的，那么`可以省略后一个赋值表达式`。因此，上述第一个 const 语句可简写为：

```go
const (
    c0 = iota       // 0
    c1              // 1
    c2              // 2
)
```

### 2.3 枚举

`枚举指一系列相关的常量`，比如下面关于一个星期中每天的定义。在 Go 语言中定义枚举值通过在 `const` 关键字后跟一对圆括号的方式定义一组常量。

```go
const (
    Sunday = iota
    Monday 
    Tuesday 
    Wednesday 
    Thursday 
    Friday 
    Saturday 
    numberOfDays
)
```

>[!important]注意：
>
>同 Go 语言的其他符号（symbol）一样，以大写字母开头的常量在包外可见。并且 Go 语言并不支持众多其他语言明确支持的 `enum` 关键字。
>

## 3. 类型

Go 语言内置以下这些基础类型：

- 布尔类型：bool
- 整型：int8、int16、int32、int64、byte、uint8、uint16、uint32、uint64、uintptr
- 浮点类型：float32、float64
- 字符串类型：string
- 字符类型：rune
- 错误类型：error
- 复数类型：complex64、complex128

:::tip 补充：

1. 类型后跟着的数字用于代表所占空间的`位数`(1 byte = 8 bit)，例如 `int64` 代表内存大小为 8 字节的整型
2. `uint`表示的`无符号整数`，与普通的 `int` 区别在于：是否可以取到负值，例如， int8： 范围 -128-127，uint8 范围：0-255
3. `uint8` 可以使用 `byte` 来进行表示
4. `int32` 可以使用 `rune` 来表示，通常代表一个 `Unicode 码`

:::

> [!IMPORTANT] 注意：
>
> - 所有的内存在 Go 中都是经过初始化的
> - 当一个变量被声明之后，系统自动赋予它该类型的零值：
> `int 为 0`，`float 为 0.0`，`bool 为 false`，`string 为空字符串`，`指针为 nil`

除开上述基本类型外，Go 还支持以下这些复合类型：

- 指针
- 数组
- 切片
- 字典
- 通道
- 结构体
- 接口

### 3.1 布尔类型

### 3.2 整形

### 3.3 浮点型

### 3.4 复数类型

### 3.5 字符串

### 3.6 字符类型

### 3.7 数组

### 3.8 数组切片

### 3.9 map

## 4. 流程控制

### 4.1 条件语句

### 4.2 选择语句

### 4.3 循环语句

### 4.4 跳转语句

## 5. 函数

### 5.1 函数定义

### 5.2 函数调用

### 5.3 不定参数

### 5.4 多返回值

### 5.5 匿名函数和闭包

## 6.错误处理

### 6.1 error 接口

### 6.2 defer

### 6.3 panic() 和 recover()

## 7. 作用域

> 一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为`作用域`。

了解变量的作用域对我们学习Go语言来说是比较重要的，因为`Go语言(静态语言)会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误`。

如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。

根据变量定义位置的不同，可以分为以下三个类型：

- 函数内定义的变量称为局部变量
- 函数外定义的变量称为全局变量
- 函数定义中的变量称为形式参数

## 5.1 局部变量

在函数体内声明的变量称之为`局部变量`，它们的作用域`只在函数体内`，函数的参数和返回值变量都属于局部变量。

**局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。**

~~~go
package main
import (
    "fmt"
)
func main() {
    //声明局部变量 a 和 b 并赋值
    var a int = 3
    var b int = 4
    //声明局部变量 c 并计算 a 和 b 的和
    c := a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
~~~

## 5.2 全局变量

在函数体外声明的变量称之为`全局变量`，全局变量只需要在`一个源文件中定义，就可以在所有源文件中使用`，当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。

全局变量声明`必须以 var 关键字开头`，如果想要在外部包中使用全局变量的`首字母必须大写`。

~~~go
package main
import "fmt"
//声明全局变量
var c int
func main() {
    //声明局部变量
    var a, b int
    //初始化参数
    a = 3
    b = 4
    c = a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
~~~

**Go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。**

~~~go
package main
import "fmt"
//声明全局变量
var bb float32 = 3.14
func main() {
 bb := 3
 fmt.Println(bb)
}
//执行结果 3
~~~

## 5.3 形式参数

在定义函数时函数名后面括号中的变量叫做`形式参数`（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参`并不占用实际的存储单元`，也没有实际值。

形式参数会作为`函数的局部变量来使用`。

~~~go
package main
import (
    "fmt"
)
//全局变量 a
var a int = 13
func main() {
    //局部变量 a 和 b
    var a int = 3
    var b int = 4
    fmt.Printf("main() 函数中 a = %d\n", a)
    fmt.Printf("main() 函数中 b = %d\n", b)
    c := sum(a, b)
    fmt.Printf("main() 函数中 c = %d\n", c)
}
func sum(a, b int) int {
    fmt.Printf("sum() 函数中 a = %d\n", a)
    fmt.Printf("sum() 函数中 b = %d\n", b)
    num := a + b
    return num
}
~~~

**至此，Go语言变量相关的知识，我们就掌握了**
